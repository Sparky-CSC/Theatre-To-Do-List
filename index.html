/***** CONFIG (EDIT THESE TWO) *****/
const SPREADSHEET_ID  = 'PASTE_YOUR_SPREADSHEET_ID_HERE';
const FORM_ID         = 'PASTE_YOUR_FORM_ID_HERE'; // from the Form edit URL

/***** CONSTANTS (usually no changes needed) *****/
const DATA_SHEET       = 'Sheet1';               // target sheet
const RESPONSES_SHEET  = 'Form Responses 1';     // form’s raw responses tab (rename if different)
const HEADER_ROW       = 1;                      // header row index
const ASSIGNEE_FALLBACK = 'EVERYONE';            // preferred fallback assignee

// Column map for Sheet1 (A..G)
const COL = {
  TITLE: 1,        // A (TASK)
  DESC:  2,        // B (DESCRIPTION)
  PRIO:  3,        // C (PRIORITY: High/Medium/Low)
  DUE_DATE: 4,     // D (DUE DATE)
  DUE_TIME: 5,     // E (TIME)
  ASSIGNEE: 6,     // F (ASSIGNED TO)
  COMPLETED: 7     // G (TRUE/FALSE)
};

/***** ONE-TIME SETUP: run this ONCE after pasting the script *****/
function setupMultiAssignFormSync() {
  // 1) Make column F validation "Show warning"
  assigneeValidationShowWarning_();

  // 2) Sync allowed assignees from column F into the Form's ASSIGNED TO checkboxes
  syncAssigneesToForm_Checkboxes();

  // 3) Attach on-submit trigger to this form
  attachFormSubmitTriggerById();
}

/***** FORM SUBMIT HANDLER: copies into Sheet1 and resorts *****/
function onTaskFormSubmit(e) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);
  if (!sh) throw new Error(`Sheet "${DATA_SHEET}" not found.`);

  // Use event payload; fallback to last response row if not present
  let nv = (e && e.namedValues) ? e.namedValues : null;
  if (!nv) {
    const resp = ss.getSheetByName(RESPONSES_SHEET);
    if (!resp) throw new Error(`Responses sheet "${RESPONSES_SHEET}" not found.`);
    const hdrs = resp.getRange(HEADER_ROW, 1, 1, resp.getLastColumn()).getValues()[0].map(String);
    const lr   = resp.getLastRow();
    if (lr <= HEADER_ROW) return;
    const vals = resp.getRange(lr, 1, 1, resp.getLastColumn()).getValues()[0];
    nv = {}; hdrs.forEach((h,i) => nv[h] = [vals[i]]);
  }

  // === Your exact Form titles ===
  const task       = first_(nv['TASK']);
  const desc       = first_(nv['DESCRIPTION']);
  const priority   = first_(nv['PRIORITY']);      // High / Medium / Low
  const dueDate    = parseDate_(first_(nv['DUE DATE']));
  const dueTime    = parseTime_(first_(nv['TIME']));
  const assigneesQ = nv['ASSIGNED TO'];           // CHECKBOXES → array

  // Turn checkbox values into a sanitized, comma-separated list
  const assigneeCell = normalizeMultiAssignees_(assigneesQ, sh); // "Name1, Name2"

  // Build output row (A..G)
  const row = [];
  row[COL.TITLE-1]     = task || '';
  row[COL.DESC-1]      = desc || '';
  row[COL.PRIO-1]      = priority || '';
  row[COL.DUE_DATE-1]  = dueDate;
  row[COL.DUE_TIME-1]  = dueTime;
  row[COL.ASSIGNEE-1]  = assigneeCell;
  row[COL.COMPLETED-1] = false;

  sh.appendRow(row);

  // Format new row and resort
  const lrOut = sh.getLastRow();
  sh.getRange(lrOut, COL.DUE_DATE).setNumberFormat('yyyy-mm-dd');
  sh.getRange(lrOut, COL.DUE_TIME).setNumberFormat('HH:mm');
  resortBy_C_then_E_then_D_(sh);
}

/***** SYNC CHECKBOXES IN FORM FROM COLUMN-F VALIDATION *****/
function syncAssigneesToForm_Checkboxes() {
  const ss   = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh   = ss.getSheetByName(DATA_SHEET);
  const list = getAllowedAssigneesFromValidation_(sh);
  if (!list.length) throw new Error('No allowed assignees found in column F validation.');

  const form = FormApp.openById(FORM_ID);
  let item = form.getItems(FormApp.ItemType.CHECKBOX)
                 .map(i => i.asCheckboxItem())
                 .find(i => i.getTitle() === 'ASSIGNED TO');
  if (!item) item = form.addCheckboxItem().setTitle('ASSIGNED TO').setRequired(false);
  item.setChoiceValues(list);
}

/***** SET COLUMN-F VALIDATION TO "SHOW WARNING" (not reject) *****/
function assigneeValidationShowWarning_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(DATA_SHEET);

  const start = HEADER_ROW + 1;
  const rng   = sh.getRange(start, COL.ASSIGNEE, Math.max(1, sh.getMaxRows()-HEADER_ROW), 1);
  const rule  = rng.getDataValidation();
  if (!rule) return;

  const type = rule.getCriteriaType();
  const args = rule.getCriteriaValues();

  let b = SpreadsheetApp.newDataValidation();
  if (type === SpreadsheetApp.DataValidationCriteria.VALUE_IN_LIST) {
    b = b.requireValueInList(args[0], true);
  } else if (type === SpreadsheetApp.DataValidationCriteria.VALUE_IN_RANGE) {
    b = b.requireValueInRange(args[0], true);
  } else {
    return;
  }

  rng.setDataValidation(
    b.setAllowInvalid(true)
     .setHelpText('Pick from the list or type multiple names (comma-separated).')
     .build()
  );
}

/***** SORT: C (High→Med→Low) → E asc → D asc; keep rows intact *****/
function resortBy_C_then_E_then_D_(sheet) {
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow <= HEADER_ROW) return;

  const dataRange = sheet.getRange(HEADER_ROW + 1, 1, lastRow - HEADER_ROW, lastCol);
  const values = dataRange.getValues();
  const rank = { high: 1, medium: 2, low: 3 }; // lower = higher priority

  values.sort((a, b) => {
    const aP = rank[String(a[COL.PRIO-1]||'').trim().toLowerCase()] ?? 99;
    const bP = rank[String(b[COL.PRIO-1]||'').trim().toLowerCase()] ?? 99;
    if (aP !== bP) return aP - bP;

    const aE = a[COL.DUE_TIME-1], bE = b[COL.DUE_TIME-1];
    if (aE !== bE) return (aE > bE) ? 1 : -1;

    const aD = a[COL.DUE_DATE-1], bD = b[COL.DUE_DATE-1];
    if (aD !== bD) return (aD > bD) ? 1 : -1;

    return 0;
  });

  dataRange.setValues(values);
}

/***** HELPERS *****/
function first_(v) {
  if (v == null) return '';
  return Array.isArray(v) ? (v[0] ?? '') : v;
}
function parseDate_(s) {
  if (!s) return '';
  const d = new Date(s);
  return isNaN(d.getTime()) ? '' : d;
}
function parseTime_(s) {
  if (!s) return '';
  const m = String(s).match(/(\d{1,2}):(\d{2})/);
  if (m) return new Date(2000,0,1, Number(m[1]), Number(m[2]), 0, 0);
  const d = new Date(s);
  return isNaN(d.getTime()) ? '' : new Date(2000,0,1, d.getHours(), d.getMinutes(), 0, 0);
}

// Read allowed assignees from col-F validation (list or range)
function getAllowedAssigneesFromValidation_(sheet) {
  const cell = sheet.getRange(HEADER_ROW + 1, COL.ASSIGNEE);
  const rule = cell.getDataValidation();
  if (!rule) return [];

  const type = rule.getCriteriaType();
  const args = rule.getCriteriaValues();

  if (type === SpreadsheetApp.DataValidationCriteria.VALUE_IN_LIST) {
    const items = (args && args[0]) ? args[0] : [];
    return items.map(s => String(s).trim()).filter(Boolean);
  }
  if (type === SpreadsheetApp.DataValidationCriteria.VALUE_IN_RANGE) {
    const listRange = args && args[0];
    if (!listRange) return [];
    return listRange.getValues().flat().map(v => String(v).trim()).filter(Boolean);
  }
  return [];
}

// Production-safe: force every name to the allowed list (fallback if unknown)
function sanitizeAssignee_(name, sheet) {
  const allowed = getAllowedAssigneesFromValidation_(sheet);
  const n = String(name || '').trim();
  if (!allowed.length) return n || ASSIGNEE_FALLBACK;

  const lower = allowed.map(v => v.toLowerCase());
  if (n) {
    const i = lower.indexOf(n.toLowerCase());
    if (i !== -1) return allowed[i];
  }
  const j = lower.indexOf(ASSIGNEE_FALLBACK.toLowerCase());
  return (j !== -1) ? allowed[j] : allowed[0];
}

// Checkbox answers or comma-separated input → "Name1, Name2"
function normalizeMultiAssignees_(values, sheet) {
  const arr = Array.isArray(values) ? values : String(values || '').split(',');
  const cleaned = arr.map(v => String(v).trim()).filter(Boolean);
  const safe = cleaned.map(n => sanitizeAssignee_(n, sheet));
  return [...new Set(safe)].join(', ');
}

/***** TRIGGER: attach submit handler to FORM_ID (run by setup) *****/
function attachFormSubmitTriggerById() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'onTaskFormSubmit') ScriptApp.deleteTrigger(t);
  });
  ScriptApp.newTrigger('onTaskFormSubmit')
    .forForm(FORM_ID)
    .onFormSubmit()
    .create();
  Logger.log('Attached onTaskFormSubmit trigger to form: ' + FORM_ID);
}
