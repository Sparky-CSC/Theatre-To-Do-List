<script>
/* ============================
   Google Sheets To-Do ‚Äî Stable ‚ÄúRemember Me‚Äù
   - Silent sign-in with login_hint + prompt:''
   - Scheduled silent refresh
   - No One Tap loops
   ============================ */

const CLIENT_ID = '429266563329-677t97fuhed0v47p5odrfog71qhcqdh6.apps.googleusercontent.com';
const API_KEY   = 'AIzaSyBgaa8xdZdWErS2zm0g-P15Gu-F-XBLc8A';
const SHEET_ID  = '1z2Pw0ZwDMYpD7-NbaM_HMPqaE62Lyla1nAstbUziJLY';
const SCOPES    = 'https://www.googleapis.com/auth/spreadsheets';

const ADMIN_EMAILS = [
  'myork@culver.edu',
  'hheaton@culver.edu',
  'dlane@culver.edu'
];

// ---- Auth state ----
let tokenClient;
let accessToken = null;
let currentUser = null;
let isAdmin = false;
let gapiReady = false;
let gisReady  = false;
let refreshTimer = null;  // token refresh timeout

// ---- App state (unchanged pieces you already use) ----
let tasks = [];
let allTasks = [];
let notificationEmails = [];
let uploadedFiles = [];
let editingTaskId = null;
let taskComments = {};

// ========== LOADERS ==========
function gapiLoaded() {
  gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
  await gapi.client.init({
    apiKey: API_KEY,
    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
  });
  gapiReady = true;
  maybeAutoSignIn();  // try silent sign-in if allowed
}

function gisLoaded() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: onTokenResponse
  });
  gisReady = true;
  maybeAutoSignIn();  // try silent sign-in if allowed
}

// ========== REMEMBER ME CORE ==========
function maybeAutoSignIn() {
  // Only run when both libs are ready
  if (!gapiReady || !gisReady) return;

  const rememberMe = localStorage.getItem('rememberMe') === 'true';
  if (!rememberMe) return;

  // Use stored email as login_hint to avoid extra prompts
  const loginHint = localStorage.getItem('loginHint') || '';

  // Silent token request ‚Äì will succeed if the user still has an active Google session on this browser.
  tokenClient.requestAccessToken({
    prompt: '',         // <-- critical: no UI if session exists
    login_hint: loginHint || undefined
  });
}

function onTokenResponse(response) {
  if (response && response.error) {
    // If we cannot get a silent token, show login screen
    console.warn('Token error:', response.error);
    showLogin();
    return;
  }

  accessToken = response.access_token;

  // Schedule silent refresh ~45 minutes later (Google tokens are ~3600s)
  scheduleTokenRefresh(45 * 60 * 1000);

  // Proceed to app (fetch user, render, etc.)
  onSignInSuccess();
}

function scheduleTokenRefresh(ms) {
  clearTimeout(refreshTimer);
  const rememberMe = localStorage.getItem('rememberMe') === 'true';
  if (!rememberMe) return; // don‚Äôt keep refreshing if they didn‚Äôt opt in

  const loginHint = localStorage.getItem('loginHint') || '';
  refreshTimer = setTimeout(() => {
    // Re-request a token silently; if session is gone, show login
    tokenClient.requestAccessToken({
      prompt: '',
      login_hint: loginHint || undefined
    });
  }, ms);
}

// ========== USER FLOWS ==========
function handleSignIn() {
  const rememberChecked = document.getElementById('rememberMe')?.checked !== false;
  if (rememberChecked) {
    localStorage.setItem('rememberMe', 'true');
  } else {
    localStorage.removeItem('rememberMe');
    localStorage.removeItem('loginHint');
  }

  // First sign-in must allow UI prompt
  tokenClient.requestAccessToken({ prompt: 'consent' });
}

function onSignInSuccess() {
  // Hide login UI, show app UI
  document.getElementById('loginScreen').style.display = 'none';
  document.getElementById('mainContent').style.display = 'block';

  // Fetch user info to know who they are + store login_hint for next silent sign-in
  fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
    headers: { Authorization: `Bearer ${accessToken}` }
  })
  .then(r => r.json())
  .then(data => {
    currentUser = data;
    if (localStorage.getItem('rememberMe') === 'true' && data?.email) {
      localStorage.setItem('loginHint', data.email.toLowerCase());
    }

    isAdmin = !!data?.email && ADMIN_EMAILS.includes(data.email.toLowerCase());

    // UI
    document.getElementById('userName').textContent = data.name + (isAdmin ? ' (Admin)' : '');
    document.getElementById('userAvatar').src = data.picture;
    document.getElementById('userInfo').style.display = 'flex';

    const createButton = document.getElementById('createBtn');
    if (createButton) createButton.style.display = isAdmin ? 'inline-flex' : 'none';

    loadToggleStates();
    loadTasks();
  })
  .catch(err => {
    console.error('userinfo error:', err);
    showLogin();
  });
}

function signOut() {
  // Clear local prefs
  localStorage.removeItem('rememberMe');
  localStorage.removeItem('loginHint');
  clearTimeout(refreshTimer);

  // Prevent auto-select reuse
  try { google.accounts.id.disableAutoSelect(); } catch (e) {}

  if (accessToken) {
    google.accounts.oauth2.revoke(accessToken, () => {
      accessToken = null;
      currentUser = null;
      isAdmin = false;
      showLogin();
    });
  } else {
    showLogin();
  }
}

function showLogin() {
  accessToken = null;
  currentUser = null;
  isAdmin = false;
  clearTimeout(refreshTimer);

  document.getElementById('loginScreen').style.display = 'block';
  document.getElementById('mainContent').style.display = 'none';
  document.getElementById('userInfo').style.display = 'none';
}

// ========== THE REST OF YOUR APP LOGIC (unchanged) ==========
// Load tasks from Google Sheets - EXCLUDES completed
async function loadTasks() {
  if (!accessToken) return;
  const todoList = document.getElementById('todoList');
  todoList.innerHTML = '<div class="loading">Loading tasks...</div>';

  try {
    const response = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID,
      range: 'Sheet1!A2:M',
    });

    const rows = response.result.values || [];
    allTasks = rows
      .map((row, index) => ({
        id: index + 2,
        task: row[0] || '',
        description: row[1] || '',
        priority: row[2] || 'Medium',
        createdBy: row[3] || '',
        completed: row[4] === 'TRUE',
        completedBy: row[5] || '',
        dateCompleted: row[6] || '',
        notify: row[7] === 'TRUE',
        notificationEmails: row[8] || '',
        category: row[9] || '',
        dueDate: row[10] || '',
        assignedTo: row[11] || '',
        comments: row[12] || ''
      }))
      .filter(task => !task.completed);

    const priorityOrder = { 'High': 1, 'Medium': 2, 'Low': 3 };
    allTasks.sort((a, b) => {
      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
      if (priorityDiff !== 0) return priorityDiff;
      if (a.dueDate && b.dueDate) return new Date(a.dueDate) - new Date(b.dueDate);
      if (a.dueDate) return -1;
      if (b.dueDate) return 1;
      return 0;
    });

    tasks = [...allTasks];
    renderTasks();
    updateStats();
    populateFilters();
  } catch (error) {
    todoList.innerHTML = `<div class="error">Error loading tasks: ${error.message}</div>`;
  }
}

function populateFilters() {
  const creators = [...new Set(allTasks.map(t => t.createdBy).filter(Boolean))];
  const creatorSelect = document.getElementById('creatorFilter');
  creatorSelect.innerHTML = '<option value="all">All</option>' +
    creators.map(c => `<option value="${c}">${c}</option>`).join('');

  const categories = [...new Set(allTasks.map(t => t.category).filter(Boolean))];
  const categorySelect = document.getElementById('categoryFilter');
  categorySelect.innerHTML = '<option value="all">All</option>' +
    categories.map(c => `<option value="${c}">${c}</option>`).join('');

  const assignees = [...new Set(allTasks.map(t => t.assignedTo).filter(Boolean))];
  const assignedSelect = document.getElementById('assignedFilter');
  assignedSelect.innerHTML = '<option value="all">All</option>' +
    assignees.map(a => `<option value="${a}">${a}</option>`).join('');
}

function applyFilters() {
  const searchTerm = document.getElementById('searchBox').value.toLowerCase();
  const priorityFilter = document.getElementById('priorityFilter').value;
  const categoryFilter = document.getElementById('categoryFilter').value;
  const creatorFilter = document.getElementById('creatorFilter').value;
  const assignedFilter = document.getElementById('assignedFilter').value;
  const dueDateFilter = document.getElementById('dueDateFilter').value;

  tasks = allTasks.filter(task => {
    if (searchTerm && !task.task.toLowerCase().includes(searchTerm) &&
        !task.description.toLowerCase().includes(searchTerm)) return false;
    if (priorityFilter !== 'all' && task.priority !== priorityFilter) return false;
    if (categoryFilter !== 'all' && task.category !== categoryFilter) return false;
    if (creatorFilter !== 'all' && task.createdBy !== creatorFilter) return false;
    if (assignedFilter !== 'all' && task.assignedTo !== assignedFilter) return false;

    if (dueDateFilter !== 'all' && task.dueDate) {
      const dueDate = new Date(task.dueDate);
      const today = new Date(); today.setHours(0,0,0,0);
      if (dueDateFilter === 'overdue' && dueDate >= today) return false;
      if (dueDateFilter === 'today' && dueDate.toDateString() !== today.toDateString()) return false;
      if (dueDateFilter === 'week') {
        const weekFromNow = new Date(today); weekFromNow.setDate(weekFromNow.getDate() + 7);
        if (dueDate < today || dueDate > weekFromNow) return false;
      }
      if (dueDateFilter === 'month') {
        const monthFromNow = new Date(today); monthFromNow.setMonth(monthFromNow.getMonth() + 1);
        if (dueDate < today || dueDate > monthFromNow) return false;
      }
    }
    return true;
  });

  const priorityOrder = { 'High': 1, 'Medium': 2, 'Low': 3 };
  tasks.sort((a, b) => {
    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
    if (priorityDiff !== 0) return priorityDiff;
    if (a.dueDate && b.dueDate) return new Date(a.dueDate) - new Date(b.dueDate);
    if (a.dueDate) return -1;
    if (b.dueDate) return 1;
    return 0;
  });

  renderTasks();
}

function updateStats() {
  gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID,
    range: 'Sheet1!E2:E',
  }).then(response => {
    const completedColumn = response.result.values || [];
    const completedCount = completedColumn.filter(row => row[0] === 'TRUE').length;
    document.getElementById('totalTasks').textContent = allTasks.length + completedCount;
    document.getElementById('completedTasks').textContent = completedCount;
    document.getElementById('pendingTasks').textContent = allTasks.length;
  });
}

function isOverdue(dueDate) {
  if (!dueDate) return false;
  const due = new Date(dueDate);
  const today = new Date(); today.setHours(0,0,0,0);
  return due < today;
}

function renderTasks() {
  const todoList = document.getElementById('todoList');
  if (tasks.length === 0) {
    todoList.innerHTML = '<div class="loading">No pending tasks found. Great job! üéâ</div>';
    return;
  }
  todoList.innerHTML = tasks.map(task => {
    const taskCommentsList = task.comments ? JSON.parse(task.comments) : [];
    const overdue = isOverdue(task.dueDate);
    return `
      <div class="todo-item priority-${task.priority.toLowerCase()}" data-id="${task.id}">
        <div class="todo-item-header">
          <div class="todo-item-left">
            <input type="checkbox" class="checkbox" onchange="toggleTask(${task.id})">
            <div class="todo-content">
              <div class="todo-title-row">
                <div class="todo-title">${task.task}</div>
                <span class="badge priority-badge priority-${task.priority.toLowerCase()}">${task.priority}</span>
                ${task.category ? `<span class="badge category-badge">${task.category}</span>` : ''}
                ${task.notify ? '<span class="badge notification-badge">üîî Notify</span>' : ''}
                ${overdue ? '<span class="badge overdue-badge">‚ö†Ô∏è Overdue</span>' : ''}
              </div>
              ${task.description ? `<div class="todo-description">${task.description}</div>` : ''}
              <div class="todo-meta">
                <div class="meta-item">üë§ Created by: <strong>${task.createdBy}</strong></div>
                ${task.assignedTo ? `<div class="meta-item">üë• Assigned to: <strong>${task.assignedTo}</strong></div>` : ''}
                ${task.dueDate ? `<div class="meta-item">üìÖ Due: <strong>${task.dueDate}</strong></div>` : ''}
                ${taskCommentsList.length > 0 ? `<div class="meta-item">üí¨ ${taskCommentsList.length} comment(s)</div>` : ''}
              </div>
              <div class="todo-actions">
                ${isAdmin ? `
                  <button class="btn btn-small btn-info" onclick="openEditTask(${task.id})">‚úèÔ∏è Edit</button>
                  <button class="btn btn-small btn-danger" onclick="deleteTask(${task.id})">üóëÔ∏è Delete</button>
                ` : ''}
                <button class="btn btn-small" onclick="toggleComments(${task.id})">üí¨ Comments</button>
              </div>
              <div class="comments-section" id="comments-${task.id}" style="display: none;">
                ${taskCommentsList.map(c => `
                  <div class="comment">
                    <div class="comment-author">${c.author}</div>
                    <div class="comment-text">${c.text}</div>
                  </div>
                `).join('')}
                <div class="comment-input-group">
                  <input type="text" class="comment-input" id="comment-input-${task.id}" placeholder="Add a comment...">
                  <button class="btn btn-small btn-success" onclick="addComment(${task.id})">Send</button>
                </div>
              </div>
            </div>
          </div>
          <div class="todo-item-right">
            <input type="text" class="initials-input" placeholder="Initials" maxlength="5" id="initials-${task.id}">
          </div>
        </div>
      </div>
    `;
  }).join('');
}

async function toggleTask(taskId) {
  const initialsInput = document.getElementById(`initials-${taskId}`);
  const initials = initialsInput?.value.trim().toUpperCase();
  if (!initials) {
    alert('Please enter your initials before marking the task as complete!');
    const checkbox = document.querySelector(`[data-id="${taskId}"] .checkbox`);
    checkbox.checked = false;
    return;
  }
  const today = new Date().toISOString().split('T')[0];
  const task = allTasks.find(t => t.id === taskId);

  try {
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `Sheet1!E${taskId}:G${taskId}`,
      valueInputOption: 'RAW',
      resource: { values: [['TRUE', initials, today]] }
    });

    if (task && task.notify && task.notificationEmails) {
      sendNotification(task, initials, today);
    }

    const idx = allTasks.findIndex(t => t.id === taskId);
    if (idx !== -1) allTasks.splice(idx, 1);

    const item = document.querySelector(`[data-id="${taskId}"]`);
    item.style.background = '#4caf50';
    item.style.color = 'white';

    const successMsg = document.createElement('div');
    successMsg.className = 'success';
    successMsg.textContent = '‚úÖ Task completed! Removed from list.';
    if (task && task.notify) successMsg.textContent += ' üìß Notifications sent!';
    item.parentElement.insertBefore(successMsg, item);

    setTimeout(() => {
      successMsg.remove();
      item.remove();
      updateStats();
      applyFilters();
    }, 1500);
  } catch (error) {
    alert('Error updating task: ' + error.message);
    const checkbox = document.querySelector(`[data-id="${taskId}"] .checkbox`);
    checkbox.checked = false;
  }
}

function sendNotification(task, completedBy, dateCompleted) {
  const emails = task.notificationEmails.split(',').map(e => e.trim());
  console.log('üìß Sending notifications to:', emails, { task: task.task, completedBy, dateCompleted });
}

// ----- Modal + save/delete/comment (unchanged from your version) -----
function openTaskModal() {
  if (!isAdmin) return alert('Only administrators can create tasks.');
  editingTaskId = null;
  document.getElementById('modalTitle').textContent = 'Create New Task';
  document.getElementById('taskForm').reset();
  notificationEmails = [];
  uploadedFiles = [];
  document.getElementById('emailTags').innerHTML = '';
  document.getElementById('fileList').innerHTML = '';
  document.getElementById('emailInputGroup').classList.remove('active');
  document.getElementById('taskModal').style.display = 'block';
}

function openEditTask(taskId) {
  if (!isAdmin) return alert('Only administrators can edit tasks.');
  const task = allTasks.find(t => t.id === taskId);
  if (!task) return;

  editingTaskId = taskId;
  document.getElementById('modalTitle').textContent = 'Edit Task';
  document.getElementById('taskTitle').value = task.task;
  document.getElementById('taskDescription').value = task.description;
  document.getElementById('taskPriority').value = task.priority;
  document.getElementById('taskCategory').value = task.category || '';
  document.getElementById('taskDueDate').value = task.dueDate || '';
  document.getElementById('taskAssignedTo').value = task.assignedTo || '';
  document.getElementById('enableNotifications').checked = task.notify;

  if (task.notify && task.notificationEmails) {
    notificationEmails = task.notificationEmails.split(',').map(e => e.trim());
    document.getElementById('emailInputGroup').classList.add('active');
    renderEmailTags();
  }
  document.getElementById('taskModal').style.display = 'block';
}

function closeTaskModal() {
  document.getElementById('taskModal').style.display = 'none';
  document.getElementById('taskForm').reset();
  notificationEmails = [];
  uploadedFiles = [];
  editingTaskId = null;
}

async function saveTask(event) {
  event.preventDefault();
  if (!isAdmin) return alert('Only administrators can save tasks.');

  const title = document.getElementById('taskTitle').value.trim();
  const description = document.getElementById('taskDescription').value.trim();
  const priority = document.getElementById('taskPriority').value;
  const category = document.getElementById('taskCategory').value.trim();
  const dueDate = document.getElementById('taskDueDate').value;
  const assignedTo = document.getElementById('taskAssignedTo').value.trim();
  const notify = document.getElementById('enableNotifications').checked;
  const emails = notificationEmails.join(',');

  if (!title) return alert('Please enter a task title!');

  try {
    if (editingTaskId) {
      await gapi.client.sheets.spreadsheets.values.update({
        spreadsheetId: SHEET_ID,
        range: `Sheet1!A${editingTaskId}:M${editingTaskId}`,
        valueInputOption: 'RAW',
        resource: {
          values: [[
            title, description, priority, currentUser.name, 'FALSE', '', '',
            notify ? 'TRUE' : 'FALSE', emails, category, dueDate, assignedTo,
            taskComments[editingTaskId] || ''
          ]]
        }
      });
    } else {
      await gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SHEET_ID,
        range: 'Sheet1!A:M',
        valueInputOption: 'RAW',
        resource: {
          values: [[
            title, description, priority, currentUser.name, 'FALSE', '', '',
            notify ? 'TRUE' : 'FALSE', emails, category, dueDate, assignedTo, ''
          ]]
        }
      });
    }

    const todoList = document.getElementById('todoList');
    const successMsg = document.createElement('div');
    successMsg.className = 'success';
    successMsg.textContent = editingTaskId ? '‚úÖ Task updated successfully!' : '‚úÖ Task created successfully!';
    todoList.insertBefore(successMsg, todoList.firstChild);
    setTimeout(() => successMsg.remove(), 2000);

    closeTaskModal();
    loadTasks();
  } catch (error) {
    alert('Error saving task: ' + error.message);
  }
}

async function deleteTask(taskId) {
  if (!isAdmin) return alert('Only administrators can delete tasks.');
  if (!confirm('Are you sure you want to delete this task?')) return;

  try {
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `Sheet1!A${taskId}:M${taskId}`,
      valueInputOption: 'RAW',
      resource: { values: [['','','','','','','','','','','','','']] }
    });

    const successMsg = document.createElement('div');
    successMsg.className = 'success';
    successMsg.textContent = '‚úÖ Task deleted successfully!';
    document.getElementById('todoList').insertBefore(successMsg, document.getElementById('todoList').firstChild);
    setTimeout(() => successMsg.remove(), 2000);
    loadTasks();
  } catch (error) {
    alert('Error deleting task: ' + error.message);
  }
}

function toggleComments(taskId) {
  const commentsSection = document.getElementById(`comments-${taskId}`);
  commentsSection.style.display = commentsSection.style.display === 'none' ? 'block' : 'none';
}

async function addComment(taskId) {
  const input = document.getElementById(`comment-input-${taskId}`);
  const text = input.value.trim();
  if (!text) return;

  const task = allTasks.find(t => t.id === taskId);
  if (!task) return;

  const comments = task.comments ? JSON.parse(task.comments) : [];
  comments.push({ author: currentUser.name, text, date: new Date().toISOString() });

  try {
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `Sheet1!M${taskId}`,
      valueInputOption: 'RAW',
      resource: { values: [[JSON.stringify(comments)]] }
    });
    input.value = '';
    loadTasks();
  } catch (error) {
    alert('Error adding comment: ' + error.message);
  }
}

// Email tag helpers
function toggleEmailInput() {
  const checkbox = document.getElementById('enableNotifications');
  const emailGroup = document.getElementById('emailInputGroup');
  if (checkbox.checked) {
    emailGroup.classList.add('active');
  } else {
    emailGroup.classList.remove('active');
    notificationEmails = [];
    document.getElementById('emailTags').innerHTML = '';
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const emailInput = document.getElementById('notificationEmails');
  if (emailInput) {
    emailInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        addEmailTag();
      }
    });
  }
});

function addEmailTag() {
  const input = document.getElementById('notificationEmails');
  const email = input.value.trim();
  if (email && validateEmail(email) && !notificationEmails.includes(email)) {
    notificationEmails.push(email);
    renderEmailTags();
    input.value = '';
  } else if (notificationEmails.includes(email)) {
    alert('This email is already added!');
  } else if (email) {
    alert('Please enter a valid email address!');
  }
}

function validateEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function renderEmailTags() {
  const container = document.getElementById('emailTags');
  container.innerHTML = notificationEmails.map((email, index) => `
    <div class="email-tag">
      ${email}
      <span class="remove" onclick="removeEmailTag(${index})">√ó</span>
    </div>
  `).join('');
}

function removeEmailTag(index) {
  notificationEmails.splice(index, 1);
  renderEmailTags();
}

// Files (unchanged)
function handleFileSelect(event) {
  const files = Array.from(event.target.files);
  files.forEach(file => {
    if (file.size > 5 * 1024 * 1024) {
      alert(`${file.name} is too large. Max size is 5MB.`);
      return;
    }
    uploadedFiles.push(file);
  });
  renderFileList();
}

function renderFileList() {
  const container = document.getElementById('fileList');
  container.innerHTML = uploadedFiles.map((file, index) => `
    <div class="file-item">
      <span class="file-item-name">üìé ${file.name}</span>
      <span class="file-item-remove" onclick="removeFile(${index})">√ó</span>
    </div>
  `).join('');
}

function removeFile(index) {
  uploadedFiles.splice(index, 1);
  renderFileList();
}

// Drag & drop
const fileUploadArea = document.getElementById('fileUploadArea');
if (fileUploadArea) {
  fileUploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    fileUploadArea.classList.add('dragover');
  });
  fileUploadArea.addEventListener('dragleave', () => {
    fileUploadArea.classList.remove('dragover');
  });
  fileUploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    fileUploadArea.classList.remove('dragover');
    const files = Array.from(e.dataTransfer.files);
    files.forEach(file => {
      if (file.size <= 5 * 1024 * 1024) uploadedFiles.push(file);
    });
    renderFileList();
  });
}

// Dark mode (unchanged)
function toggleDarkMode() {
  document.body.classList.toggle('dark-mode');
  const isDark = document.body.classList.contains('dark-mode');
  localStorage.setItem('darkMode', isDark);
  document.querySelector('.dark-mode-toggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
}
if (localStorage.getItem('darkMode') === 'true') {
  document.body.classList.add('dark-mode');
  document.querySelector('.dark-mode-toggle').textContent = '‚òÄÔ∏è';
}

// Exporters (unchanged)
function exportToPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(18);
  doc.text('Team To-Do List', 14, 20);
  doc.setFontSize(10);
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, 14, 28);
  doc.text(`Total Tasks: ${tasks.length}`, 14, 34);
  const tableData = tasks.map(task => [
    task.task,
    task.priority,
    task.category || 'N/A',
    task.assignedTo || 'Unassigned',
    task.dueDate || 'No due date',
    task.createdBy
  ]);
  doc.autoTable({
    head: [['Task','Priority','Category','Assigned To','Due Date','Created By']],
    body: tableData,
    startY: 40,
    styles: { fontSize: 8 },
    headStyles: { fillColor: [102,126,234] }
  });
  doc.save('todo-list.pdf');
}

function exportToExcel() {
  const data = tasks.map(task => ({
    'Task': task.task,
    'Description': task.description,
    'Priority': task.priority,
    'Category': task.category || '',
    'Created By': task.createdBy,
    'Assigned To': task.assignedTo || '',
    'Due Date': task.dueDate || '',
    'Notify': task.notify ? 'Yes' : 'No'
  }));
  const ws = XLSX.utils.json_to_sheet(data);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Tasks');
  XLSX.writeFile(wb, 'todo-list.xlsx');
}

// UI toggles (unchanged)
function toggleExports() {
  const exportButtons = document.getElementById('exportButtons');
  const icon = document.getElementById('exportToggleIcon');
  if (exportButtons.classList.contains('hidden')) {
    exportButtons.classList.remove('hidden'); icon.textContent = 'üì§';
    localStorage.setItem('exportsVisible','true');
  } else {
    exportButtons.classList.add('hidden'); icon.textContent = 'üì•';
    localStorage.setItem('exportsVisible','false');
  }
}

function toggleFilters() {
  const filterSection = document.getElementById('filterSection');
  const icon = document.getElementById('filterToggleIcon');
  if (filterSection.classList.contains('collapsed')) {
    filterSection.classList.remove('collapsed'); icon.textContent = 'üîΩ';
    localStorage.setItem('filtersVisible','true');
  } else {
    filterSection.classList.add('collapsed'); icon.textContent = '‚ñ∂Ô∏è';
    localStorage.setItem('filtersVisible','false');
  }
}

function loadToggleStates() {
  const exportsVisible = localStorage.getItem('exportsVisible');
  const filtersVisible = localStorage.getItem('filtersVisible');
  if (exportsVisible === 'false') {
    document.getElementById('exportButtons').classList.add('hidden');
    document.getElementById('exportToggleIcon').textContent = 'üì•';
  }
  if (filtersVisible === 'false') {
    document.getElementById('filterSection').classList.add('collapsed');
    document.getElementById('filterToggleIcon').textContent = '‚ñ∂Ô∏è';
  }
}

// Close modal when clicking outside
window.onclick = function(event) {
  const modal = document.getElementById('taskModal');
  if (event.target === modal) closeTaskModal();
};

// Expose for HTML handlers
window.gapiLoaded = gapiLoaded;
window.gisLoaded  = gisLoaded;
window.handleSignIn = handleSignIn;
window.signOut = signOut;
window.toggleDarkMode = toggleDarkMode;
window.openTaskModal = openTaskModal;
window.openEditTask = openEditTask;
window.closeTaskModal = closeTaskModal;
window.saveTask = saveTask;
window.deleteTask = deleteTask;
window.applyFilters = applyFilters;
window.loadTasks = loadTasks;
window.toggleComments = toggleComments;
window.addComment = addComment;
window.exportToPDF = exportToPDF;
window.exportToExcel = exportToExcel;
window.toggleExports = toggleExports;
window.toggleFilters = toggleFilters;

// Auto-refresh tasks every 2 minutes (only if signed in)
setInterval(() => { if (accessToken) loadTasks(); }, 120000);
</script>
